<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>NiTE 2.0: nite::HandTracker Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="PrimeSenseLogo.bmp"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">NiTE 2.0
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacenite.html">nite</a>      </li>
      <li class="navelem"><a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">nite::HandTracker Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="nite::HandTracker" -->
<p><code>#include &lt;<a class="el" href="_ni_t_e_8h_source.html">NiTE.h</a>&gt;</code></p>

<p><a href="classnite_1_1_hand_tracker-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker_1_1_new_frame_listener.html">NewFrameListener</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a0a86dbd07a0df756179890a8c75ee5fc">HandTracker</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a02ba9b3d1ae978f6c7e7912c69f3dec5">~HandTracker</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a5b5293bd58bba5f1fd9956a38f762892">addNewFrameListener</a> (<a class="el" href="classnite_1_1_hand_tracker_1_1_new_frame_listener.html">NewFrameListener</a> *pListener)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#aeffa51ae7c64795875fe187bf448c569">convertDepthCoordinatesToHand</a> (int x, int y, int z, float *pOutX, float *pOutY) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#aaaea4bd5f743f7ebd0c770798f2f43e9">convertHandCoordinatesToDepth</a> (float x, float y, float z, float *pOutX, float *pOutY) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a13e33adf632a08108fb39f1a0c6e39b6">create</a> (openni::Device *pDevice=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#aee7f820ae48361880b02e53327a460c8">destroy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a3b4f4f538c13105b3d857d7b1a394749">getSmoothingFactor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#ae840f089c301ccde8295d1ac13faf83a">isValid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a32dc5b57dda1d8273862b05fdfba9eff">readFrame</a> (<a class="el" href="classnite_1_1_hand_tracker_frame_ref.html">HandTrackerFrameRef</a> *pFrame)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a3a8152fe82d8223cb88efbda3aa814cd">removeNewFrameListener</a> (<a class="el" href="classnite_1_1_hand_tracker_1_1_new_frame_listener.html">NewFrameListener</a> *pListener)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a0134ab380e121985b7a00c41999b3d20">setSmoothingFactor</a> (float factor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a54856665ceb067648810664513734cc5">startGestureDetection</a> (<a class="el" href="namespacenite.html#afe0c50ec0aff2315efa8998e6b839da4">GestureType</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a3dc627225c06f3e74a1c9be2ebe82183">startHandTracking</a> (const <a class="el" href="classnite_1_1_point3f.html">Point3f</a> &amp;position, <a class="el" href="namespacenite.html#a820607503a84de8a025c74d1d40d6733">HandId</a> *pNewHandId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#a960676008aaccc741bc4ca524c7db82b">stopGestureDetection</a> (<a class="el" href="namespacenite.html#afe0c50ec0aff2315efa8998e6b839da4">GestureType</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnite_1_1_hand_tracker.html#adef12f62aa3ada080a73f5a591b8b3b9">stopHandTracking</a> (<a class="el" href="namespacenite.html#a820607503a84de8a025c74d1d40d6733">HandId</a> id)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is the main object of the Hand Tracker algorithm. It (along with <a class="el" href="classnite_1_1_user_tracker.html">UserTracker</a>) is one of two main classes in <a class="el" href="classnite_1_1_ni_t_e.html">NiTE</a>. All <a class="el" href="classnite_1_1_ni_t_e.html">NiTE</a> algorithms are accessable through one of these two classes.</p>
<p><a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> provides access to all algorithms relates to tracking individual hands, as well as detecting gestures in the depthmap.</p>
<p>The core of the hand tracking is an algorithm that finds human hands in each from of the depthmap, and reports the position of those hands in space. This can be used for simple detection of higher level gestures and implimentation of gesture based user interfaces. Unlike full body tracking algorithms, handpoint based tracking works on users that are sitting and does not require a full body be visible.</p>
<p>Gesture tracking is generally used to initiate hand tracking. It allows detection of gestures in the raw depth map, without requiring hand points (in contrast to higher-level gestures that might be used to impliment a UI using handpoints). These gestures can be located in space to provide a hint to the hand tracking algorithm on where to start tracking.</p>
<p>The output of the <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> occurs one frame at a time. For each input depth frame, a hand tracking frame is output with hand positions, gesture positions, etc. A listener class is provided that allows for event driven reaction to each new frame as it arrives.</p>
<p>Note that creating a <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> requires a valid OpenNI 2.0 Device to be initialized in order to provide depth information. See the OpenNI 2.0 documenation for information on connecting a device and starting the stream of depth maps that will drive this algorithm.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classnite_1_1_user_tracker.html">UserTracker</a> If you want to track full body motion, skeletons, find a floor plane, or detect poses. </dd>
<dd>
<a class="el" href="classnite_1_1_ni_t_e.html">NiTE</a> For a list of static functions that must be used before using <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0a86dbd07a0df756179890a8c75ee5fc"></a><!-- doxytag: member="nite::HandTracker::HandTracker" ref="a0a86dbd07a0df756179890a8c75ee5fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnite_1_1_hand_tracker.html#a0a86dbd07a0df756179890a8c75ee5fc">nite::HandTracker::HandTracker</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor. Creates an empty <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> with a NULL handle. This object will not be useful until the <a class="el" href="classnite_1_1_hand_tracker.html#a13e33adf632a08108fb39f1a0c6e39b6">create()</a> function is called.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classnite_1_1_hand_tracker.html#a13e33adf632a08108fb39f1a0c6e39b6">HandTracker::create()</a> for a function to <a class="el" href="classnite_1_1_hand_tracker.html#a13e33adf632a08108fb39f1a0c6e39b6">create</a> and activate the algorithm. </dd>
<dd>
<a class="el" href="classnite_1_1_hand_tracker.html#ae840f089c301ccde8295d1ac13faf83a">HandTracker::isValid()</a> to determine whether <a class="el" href="classnite_1_1_hand_tracker.html#a13e33adf632a08108fb39f1a0c6e39b6">create()</a> has already been called. </dd></dl>

</div>
</div>
<a class="anchor" id="a02ba9b3d1ae978f6c7e7912c69f3dec5"></a><!-- doxytag: member="nite::HandTracker::~HandTracker" ref="a02ba9b3d1ae978f6c7e7912c69f3dec5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnite_1_1_hand_tracker.html#a02ba9b3d1ae978f6c7e7912c69f3dec5">nite::HandTracker::~HandTracker</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. Automatically calls the provided <a class="el" href="classnite_1_1_hand_tracker.html#aee7f820ae48361880b02e53327a460c8">destroy()</a> function. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5b5293bd58bba5f1fd9956a38f762892"></a><!-- doxytag: member="nite::HandTracker::addNewFrameListener" ref="a5b5293bd58bba5f1fd9956a38f762892" args="(NewFrameListener *pListener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnite_1_1_hand_tracker.html#a5b5293bd58bba5f1fd9956a38f762892">nite::HandTracker::addNewFrameListener</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnite_1_1_hand_tracker_1_1_new_frame_listener.html">NewFrameListener</a> *&#160;</td>
          <td class="paramname"><em>pListener</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a NewFrameListner object to this <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> so that it will respond when a new frame is generated.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pListener</td><td>Pointer to a listener to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classnite_1_1_hand_tracker_1_1_new_frame_listener.html">HandTracker::NewFrameListener</a> for more information on using event based interaction with <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeffa51ae7c64795875fe187bf448c569"></a><!-- doxytag: member="nite::HandTracker::convertDepthCoordinatesToHand" ref="aeffa51ae7c64795875fe187bf448c569" args="(int x, int y, int z, float *pOutX, float *pOutY) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> <a class="el" href="classnite_1_1_hand_tracker.html#aeffa51ae7c64795875fe187bf448c569">nite::HandTracker::convertDepthCoordinatesToHand</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In general, two coordinate systems are used in OpenNI 2.0. These conventions are also followed in <a class="el" href="classnite_1_1_ni_t_e.html">NiTE</a> 2.0.</p>
<p>Hand pont and gesture positions are provided in "Real World" coordinates, while the native coordinate system of depth maps is the "projective" system. In short, "Real World" coordinates locate objects using a Cartesian coordinate system with the origin at the sensor. "Projective" coordinates measure straight line distance from the sensor, and indicate x/y coordinates using pixels in the image (which is mathematically equivalent to specifying angles). See the OpenNI 2.0 documentation online for more information.</p>
<p>This function allows you to convert the native depth map coordinates to the system used by the hand points. This might be useful for performing certain types of measurements (eg distance between a hand and an object identified only in the depth map).</p>
<p>Note that no output is given for the Z coordinate. Z coordinates remain the same when performing the conversion. An input value is still required for Z, since this can affect the x/y output.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input X coordinate using the "projective" coordinate system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The input Y coordinate using the "projective" coordinate system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>The input Z coordinate using the "projective" coordinate system. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutX</td><td>Pointer to a location to store the output X coordinate in the "real world" system. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutY</td><td>Pointer to a location to store the output Y coordinate in the "real world" system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> indicating success or failure of this operation. This is needed because the ability to convert between coordinate systems requires a properly initalized Device from OpenNI 2.0. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaea4bd5f743f7ebd0c770798f2f43e9"></a><!-- doxytag: member="nite::HandTracker::convertHandCoordinatesToDepth" ref="aaaea4bd5f743f7ebd0c770798f2f43e9" args="(float x, float y, float z, float *pOutX, float *pOutY) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> <a class="el" href="classnite_1_1_hand_tracker.html#aaaea4bd5f743f7ebd0c770798f2f43e9">nite::HandTracker::convertHandCoordinatesToDepth</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pOutY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In general, two coordinate systems are used in OpenNI 2.0. These conventions are also followed in <a class="el" href="classnite_1_1_ni_t_e.html">NiTE</a> 2.0.</p>
<p>Hand point and gesture positions are provided in "Real World" coordinates, while the native coordinate system of depth maps is the "projective" system. In short, "Real World" coordinates locate objects using a Cartesian coordinate system with the origin at the sensor. "Projective" coordinates measure straight line distance from the sensor (perpendicular to the sensor face), and indicate x/y coordinates using pixels in the image (which is mathematically equivalent to specifying angles). See the OpenNI 2.0 documentation online for more information.</p>
<p>Note that no output is given for the Z coordinate. Z coordinates remain the same when performing the conversion. An input value is still required for Z, since this can affect the x/y output.</p>
<p>This function allows you to convert the coordinates of a hand point or gesture to the native coordinates of a depth map. This is useful if you need to find the hand position on the raw depth map.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input X coordinate using the "real world" coordinate system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The input Y coordinate using the "real world" coordinate system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>The input Z coordinate using the "real world" coordinate system. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutX</td><td>Pointer to a location to store the output X coordinate in the "projective" system. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutY</td><td>Pointer to a location to store the output Y coordinate in the "projective" system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> indicating success or failure of this operation. This is needed because the ability to convert between coordinate systems requires a properly initalized Device from OpenNI 2.0. </dd></dl>

</div>
</div>
<a class="anchor" id="a13e33adf632a08108fb39f1a0c6e39b6"></a><!-- doxytag: member="nite::HandTracker::create" ref="a13e33adf632a08108fb39f1a0c6e39b6" args="(openni::Device *pDevice=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> <a class="el" href="classnite_1_1_hand_tracker.html#a13e33adf632a08108fb39f1a0c6e39b6">nite::HandTracker::create</a> </td>
          <td>(</td>
          <td class="paramtype">openni::Device *&#160;</td>
          <td class="paramname"><em>pDevice</em> = <code>NULL</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates and initializes an empty <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a>. This function should be the first one called when a new <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> object is constructed.</p>
<p>An OpenNI device with depth capabilities is required for this algorithm to work. See the OpenNI 2.0 documentation for more information about using an OpenNI 2.0 compliant hardware device and creating a Device object.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDevice</td><td>A pointer to an initalized OpenNI 2.0 Device object that provides depth streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A status code to indicate success/failure. Since this relies on an external hardware device, it is important for applications to check this value.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> enumeration for a list of all possible status values generated by this call. </dd></dl>

</div>
</div>
<a class="anchor" id="aee7f820ae48361880b02e53327a460c8"></a><!-- doxytag: member="nite::HandTracker::destroy" ref="aee7f820ae48361880b02e53327a460c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnite_1_1_hand_tracker.html#aee7f820ae48361880b02e53327a460c8">nite::HandTracker::destroy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shuts down the hand tracker and releases all resources used by it.</p>
<p>This is the opposite of <a class="el" href="classnite_1_1_hand_tracker.html#a13e33adf632a08108fb39f1a0c6e39b6">create()</a>. This function is called automatically by the destructor in the current implimentation, but it is good practice to run it manually when the algorithm is no longer required. Running this function more than once is safe -- it simply exits if called on a non-valid <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a>. </p>

</div>
</div>
<a class="anchor" id="a3b4f4f538c13105b3d857d7b1a394749"></a><!-- doxytag: member="nite::HandTracker::getSmoothingFactor" ref="a3b4f4f538c13105b3d857d7b1a394749" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classnite_1_1_hand_tracker.html#a3b4f4f538c13105b3d857d7b1a394749">nite::HandTracker::getSmoothingFactor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queries the current hand smoothing factor.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current hand smoothing factor.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classnite_1_1_hand_tracker.html#a0134ab380e121985b7a00c41999b3d20">setSmoothingFactor</a> for more information on the smoothing factor, and the means to change it. </dd></dl>

</div>
</div>
<a class="anchor" id="ae840f089c301ccde8295d1ac13faf83a"></a><!-- doxytag: member="nite::HandTracker::isValid" ref="ae840f089c301ccde8295d1ac13faf83a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnite_1_1_hand_tracker.html#ae840f089c301ccde8295d1ac13faf83a">nite::HandTracker::isValid</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicates whether the <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> is valid.</p>
<p>When a new <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> is first constructed, this function will indicate that it is invalid (ie return False). Once the <a class="el" href="classnite_1_1_hand_tracker.html#a13e33adf632a08108fb39f1a0c6e39b6">create()</a> function has been successfully called, then this function will return True. If the <a class="el" href="classnite_1_1_hand_tracker.html#aee7f820ae48361880b02e53327a460c8">destroy()</a> function is called, this function will again indicate invalid.</p>
<p>It is safe to run <a class="el" href="classnite_1_1_hand_tracker.html#a13e33adf632a08108fb39f1a0c6e39b6">create()</a> and <a class="el" href="classnite_1_1_hand_tracker.html#aee7f820ae48361880b02e53327a460c8">destroy()</a> without calling this function -- both of those functions already check this value and return without doing anything if no action is required.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a> object is correctly initialized, False otherwise.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classnite_1_1_hand_tracker.html#a13e33adf632a08108fb39f1a0c6e39b6">create()</a> function -- causes the <a class="el" href="classnite_1_1_user_tracker.html">UserTracker</a> to become initialized. </dd>
<dd>
<a class="el" href="classnite_1_1_hand_tracker.html#aee7f820ae48361880b02e53327a460c8">destroy()</a> function -- causes the <a class="el" href="classnite_1_1_user_tracker.html">UserTracker</a> to become uninitialized. </dd></dl>

</div>
</div>
<a class="anchor" id="a32dc5b57dda1d8273862b05fdfba9eff"></a><!-- doxytag: member="nite::HandTracker::readFrame" ref="a32dc5b57dda1d8273862b05fdfba9eff" args="(HandTrackerFrameRef *pFrame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> <a class="el" href="classnite_1_1_hand_tracker.html#a32dc5b57dda1d8273862b05fdfba9eff">nite::HandTracker::readFrame</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnite_1_1_hand_tracker_frame_ref.html">HandTrackerFrameRef</a> *&#160;</td>
          <td class="paramname"><em>pFrame</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the next snapshot of the algorithm. This causes all data to be generated for the next frame of the algorithm -- algorithm frames correspond to the input depth frames used to generate them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pFrame</td><td>[out] A pointer that will be set to point to the next frame of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status code indicating whether this operation was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a8152fe82d8223cb88efbda3aa814cd"></a><!-- doxytag: member="nite::HandTracker::removeNewFrameListener" ref="a3a8152fe82d8223cb88efbda3aa814cd" args="(NewFrameListener *pListener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnite_1_1_hand_tracker.html#a3a8152fe82d8223cb88efbda3aa814cd">nite::HandTracker::removeNewFrameListener</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnite_1_1_hand_tracker_1_1_new_frame_listener.html">NewFrameListener</a> *&#160;</td>
          <td class="paramname"><em>pListener</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes a <a class="el" href="classnite_1_1_hand_tracker_1_1_new_frame_listener.html">NewFrameListener</a> object from this <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a>'s list of listeners. The listener will no longer respond when a new frame is generated.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pListener</td><td>Pointer to a listener to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classnite_1_1_hand_tracker_1_1_new_frame_listener.html">HandTracker::NewFrameListener</a> for more information on using event based interaction with <a class="el" href="classnite_1_1_hand_tracker.html">HandTracker</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0134ab380e121985b7a00c41999b3d20"></a><!-- doxytag: member="nite::HandTracker::setSmoothingFactor" ref="a0134ab380e121985b7a00c41999b3d20" args="(float factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> <a class="el" href="classnite_1_1_hand_tracker.html#a0134ab380e121985b7a00c41999b3d20">nite::HandTracker::setSmoothingFactor</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Control the smoothing factor of the hand points. Factor should be between 0 (no smoothing at all) and 1 (no movement at all).</p>
<p>Experimenting with this factor should allow you to fine tune the hand tracking performance. Higher values will produce smoother movement of the handpoints, but may make the handpoints feel less responsive to the user. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>The smoothing factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status code indicating success or failure of this operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a54856665ceb067648810664513734cc5"></a><!-- doxytag: member="nite::HandTracker::startGestureDetection" ref="a54856665ceb067648810664513734cc5" args="(GestureType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> <a class="el" href="classnite_1_1_hand_tracker.html#a54856665ceb067648810664513734cc5">nite::HandTracker::startGestureDetection</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenite.html#afe0c50ec0aff2315efa8998e6b839da4">GestureType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start detecting a specific gesture. This function will cause the algorithm to start scanning the entire field of view for any hand that appears to be performing the gesture specified. Intermediate progress is available to aid in providing feedback to the user.</p>
<p>Gestures are detected from the raw depth map. They don't depend on hand points. They are most useful for determining where a hand is in space to start hand tracking. Unlike handpoints, they do not follow a specific hand, so they will react to a hand anywhere in the room.</p>
<p>If you want to detect user gestures for input purposes, it is often better to use a single "focus" gesture to start hand tracking, and then detect other gestures from the handpoints. This enables an application to focus on a single user, even in a crowded room.</p>
<p>Hand points can also be more computationally efficient. The gesture tracking algorithm for any given gesture uses about as much CPU bandwidth as the hand tracker. Adding more gestures or also running the hand tracker increases CPU consumption linearly. Finding gestures from hand points, on the other hand, can be done for negligable CPU cost once the handpoint algorithm has run. This means that user interface complexity will scale better with CPU complexity.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">@ref</td><td>GestureType you wish to detect </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> indicating success or failure of this operation.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classnite_1_1_user_tracker.html">UserTracker</a> if you want to do full body poses instead of hand-only gestures </dd>
<dd>
<a class="el" href="namespacenite.html#afe0c50ec0aff2315efa8998e6b839da4">GestureType</a> enumeration for list of available gestures. </dd>
<dd>
<a class="el" href="classnite_1_1_hand_tracker.html#a960676008aaccc741bc4ca524c7db82b">stopGestureDetection</a> to stop detection once it has started. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dc627225c06f3e74a1c9be2ebe82183"></a><!-- doxytag: member="nite::HandTracker::startHandTracking" ref="a3dc627225c06f3e74a1c9be2ebe82183" args="(const Point3f &amp;position, HandId *pNewHandId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> <a class="el" href="classnite_1_1_hand_tracker.html#a3dc627225c06f3e74a1c9be2ebe82183">nite::HandTracker::startHandTracking</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnite_1_1_point3f.html">Point3f</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenite.html#a820607503a84de8a025c74d1d40d6733">HandId</a> *&#160;</td>
          <td class="paramname"><em>pNewHandId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts tracking a hand at a specific point in space. Use of this function assumes that there actually is a hand in the location given. In general, the hand algorithm is much better at tracking a specific hand as it moves around than it is at finding the hand in the first place.</p>
<p>This function is typically used in conjunction with gesture detection. The position in space of the gesture is used to initiate hand tracking. It is also possible to start hand tracking without a gesture if your application will constrain users to place their hands in a certain known point in space. A final possibility is for applications or third party middleware to impliment their own hand 'finding' algorithm either in depth or from some other information source, and using that data to initialize the hand tracker.</p>
<p>The position in space of the hand point is specified in "real world" coordinates. See OpenNI 2.0 documentation for more information on coordinate systems.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Point</td><td>where hand is known/suspected to exist. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ID</td><td>to assign a hand once tracking starts. This will be used to refer to the hand later. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="namespacenite.html#a462094ef424d8ac580ad58986cd8b7a9">Status</a> code indicating success or failure of this operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a960676008aaccc741bc4ca524c7db82b"></a><!-- doxytag: member="nite::HandTracker::stopGestureDetection" ref="a960676008aaccc741bc4ca524c7db82b" args="(GestureType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnite_1_1_hand_tracker.html#a960676008aaccc741bc4ca524c7db82b">nite::HandTracker::stopGestureDetection</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenite.html#afe0c50ec0aff2315efa8998e6b839da4">GestureType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop detecting a specific gesture. This disables detection of the specified gesture. Doing this when that gesture is no longer required prevents false detection and saves CPU bandwidth.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">@ref</td><td>GestureType you would like to stop detecting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adef12f62aa3ada080a73f5a591b8b3b9"></a><!-- doxytag: member="nite::HandTracker::stopHandTracking" ref="adef12f62aa3ada080a73f5a591b8b3b9" args="(HandId id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnite_1_1_hand_tracker.html#adef12f62aa3ada080a73f5a591b8b3b9">nite::HandTracker::stopHandTracking</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenite.html#a820607503a84de8a025c74d1d40d6733">HandId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Commands the algorithm to stop tracking a specific hand. Note that the algorithm may be tracking more than one hand. This function only halts tracking on the single hand specified.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The <a class="el" href="namespacenite.html#a820607503a84de8a025c74d1d40d6733">HandId</a> of the hand to quit tracking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ni_t_e_8h_source.html">NiTE.h</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 22 2013 20:04:48 for NiTE 2.0 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
